% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate.R
\name{vs_simulate_set}
\alias{vs_simulate_set}
\alias{vs_simulate_set_mc}
\alias{vs_simulate_set_theor}
\title{Simulate a set of volleyball}
\usage{
vs_simulate_set(
  rates,
  process_model = "phase",
  serving = NA,
  go_to = 25,
  point_margin = 2,
  simple = FALSE,
  id = NULL,
  method = "theoretical"
)

vs_simulate_set_mc(...)

vs_simulate_set_theor(...)
}
\arguments{
\item{rates}{list: A two-element list, each element of which is a set of rates as returned by \code{vs_estimate_rates}. Experimental: for \code{process_model} "sideout", the \code{sideout} rate component can be a function. This function will be called at each step of the simulation with the parameters:
\itemize{
\item \code{team_1_score} - the score of team 1 at each point in the set so far
\item \code{team_2_score} - the score of team 2 at each point in the set so far
\item \code{team_1_rotation} - the rotation of team 1 at each point in the set so far (rotations are counted relative to the team's starting rotation, which is 1)
\item \code{team_2_rotation} - the rotation of team 2 at each point in the set so far (rotations are counted relative to the team's starting rotation, which is 1)
\item \code{serving} - the serving team 1 or 2 at each point in the set so far
\item \code{point_won_by} - which team won each point in the set so far (this will be NA for the last entry, because that's the current point that hasn't been simulated yet)
\item \code{outcome} - the outcome of each point in the set so far, either "Sideout" or "Breakpoint" if \code{process_model} is "sideout", or details TBD if \code{process_model} is "phase"
The function should return the sideout rate of the receiving team.
}}

\item{process_model}{string: either "sideout" or "phase". The "sideout" model uses the estimated sideout rates (in the \code{rates} object) directly. The "phase" model breaks play down into different phases (serve, serve receive, etc) and uses the rates associated with those separate phases}

\item{serving}{logical: if \code{TRUE}, team 1 will serve first. If \code{NA}, the team serving first will be chosen at random}

\item{go_to}{integer: the minimum score that must be reached to end the set (typically 25 for indoor volleyball in sets 1 to 4, 15 in set 5, or 21 in beach volleyball)}

\item{point_margin}{integer: the minimum score difference in order to win the set. Only applicable to \code{method} "monte carlo". For \code{method} "theoretical" a two-point margin is always used}

\item{simple}{logical: if \code{TRUE}, return simplified output. Only applicable to \code{method} "monte carlo". If \code{simple = TRUE}, return the team (1 or 2) that won the set. If \code{simple = FALSE}, return extra details in a data.frame}

\item{id}{: an optional value that (if non-\code{NULL}) will be returned in the \code{id} column of the returned data frame, if \code{simple} is \code{FALSE}}

\item{method}{string: the simulation method to use. Either "monte carlo" or "theoretical". Details TBD}

\item{...}{: parameters as for \code{vs_simulate_set}. \code{vs_simulate_set_theor} and \code{vs_simulate_set_mc} are convenience functions for \code{vs_simulate_set(..., method = "theoretical")} and \code{vs_simulate_set(..., method = "monte carlo")} respectively}
}
\value{
Integer (1 or 2) or a data frame, depending on the value of \code{simple}
}
\description{
\code{vs_simulate_set_theor} and \code{vs_simulate_set_mc} are convenience functions for \code{vs_simulate_set(..., method = "theoretical")} and \code{vs_simulate_set(..., method = "monte carlo")} respectively.
}
\examples{
\dontrun{
  library(datavolley)
  x <- dv_read(dv_example_file())
  rates <- vs_estimate_rates(x, target_team = "each")

  vs_simulate_set(rates) ## simulate a single set
  vs_simulate_match(rates) ## simulate a match
  ## so given the performances of the two teams during that match, we expect
  ##  that the home team should have won, with 3-0 being the most likely scoreline

  ## compare to the actual match result
  summary(x)
}

## sideout rates as a function for team 2
sofun2 <- function(serving, point_won_by, ...) {
    ## if team 2 won their previous sideout opportunity, their sideout rate is 0.6
    ## otherwise it's 0.5
    prevso <- tail(na.omit(point_won_by[serving == 1]), 1)
    if (length(prevso) < 1 || prevso == 1) {
        ## first sideout opportunity or lost the last one
        0.5
    } else {
        0.6
    }
}

rates <- list(list(sideout = 0.55), ## first team has constant 55\% sideout rate
               list(sideout = sofun2)) ## function for team 2's sideout rate

## need to use method = "monte carlo" for this
vs_simulate_set(rates = rates, process_model = "sideout", method = "monte carlo")

}
\seealso{
\code{\link[=vs_estimate_rates]{vs_estimate_rates()}} \code{\link[=vs_simulate_match]{vs_simulate_match()}}
}
